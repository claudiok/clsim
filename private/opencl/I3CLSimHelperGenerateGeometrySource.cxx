#include "opencl/I3CLSimHelperGenerateGeometrySource.h"

#include <string>
#include <sstream>
#include <stdexcept>

#include <vector>
#include <set>

#include "dataclasses/I3Constants.h"

#include <boost/lexical_cast.hpp>
#include <boost/foreach.hpp>

#include "clsim/cl.hpp"

#include "clsim/to_float_string.h"


namespace I3CLSimHelper
{
    
    // forward
    bool write_geometry_code_and_fill_buffer(std::string &code, 
                                             const std::vector<int> &stringIDs,
                                             const std::vector<unsigned int> &domIDs,
                                             const std::vector<double> &posX,
                                             const std::vector<double> &posY,
                                             const std::vector<double> &posZ,
                                             const double omRadius,
                                             std::vector<cl_int> &domIDbuffer,
                                             std::vector<cl_float> &domPosBuffer,
                                             std::vector<cl_uchar> &geoLayerToOMNumIndexPerStringSetBuffer
                                             );
    
    // the main converter
    std::string GenerateGeometrySource(const I3CLSimSimpleGeometry &geometry,
                                       std::vector<unsigned char> &geoLayerToOMNumIndexPerStringSetBuffer)
    {
        geoLayerToOMNumIndexPerStringSetBuffer.clear();
        
        std::ostringstream code;
        
        code << "\n";
        code << "///////////////// BEGIN ice/water properties ////////////\n";
        code << "\n";

        code << "// ice/water properties, auto-generated by\n";
        code << "// I3CLSimHelper::GenerateGeometrySource()\n";
        code << "\n";

        std::vector<cl_int> domIDbuffer;
        std::vector<cl_float> domPosBuffer;

        {
            std::string geo_code;
            bool ret = 
            write_geometry_code_and_fill_buffer(geo_code, 
                                                geometry.GetStringIDVector(),
                                                geometry.GetDomIDVector(),
                                                geometry.GetPosXVector(),
                                                geometry.GetPosYVector(),
                                                geometry.GetPosZVector(),
                                                geometry.GetOMRadius(),
                                                domIDbuffer,
                                                domPosBuffer,
                                                geoLayerToOMNumIndexPerStringSetBuffer
                                                );
            
            if (!ret)
                throw std::runtime_error("Could not use this geometry for OpenCL.");
            
            code << geo_code;
        }        
        
        code << "\n";
        code << "///////////////// END ice/water properties ////////////\n";
        code << "\n";

        
        return code.str();
    }
    

    
    /////////// HELPERS
    
    struct domStruct {
        unsigned int domID;
        double posX, posY, posZ;
    };
    
    struct stringStruct {
        int stringID;
        double meanX;
        double meanY;
        double maxZ, minZ;
        double maxR;
        std::vector<domStruct> doms;
    };
    
    bool divideIntoCells(const std::vector<stringStruct> &strings,
                         double &cellStartX,
                         double &cellStartY,
                         double &cellWidthX,
                         double &cellWidthY,
                         unsigned int cellNumX,
                         unsigned int cellNumY,
                         std::vector<unsigned short> &cellToStringIndex)
    {
        if ((cellNumX==0) || (cellNumY==0)) return false;
        if (strings.size()<=0) return false;
        
        cellToStringIndex.resize(cellNumX*cellNumY);
        
        // find minimum x and y detector coordinates
        double minX=NAN, minY=NAN, maxX=NAN, maxY=NAN;
        BOOST_FOREACH(const stringStruct &currentString, strings)
        {
            if ((currentString.meanX-currentString.maxR < minX) || isnan(minX)) {
                minX = currentString.meanX-currentString.maxR;
            }
            if ((currentString.meanY-currentString.maxR < minY) || isnan(minY)) {
                minY = currentString.meanY-currentString.maxR;
            }
            if ((currentString.meanX+currentString.maxR > maxX) || isnan(maxX)) {
                maxX = currentString.meanX+currentString.maxR;
            }
            if ((currentString.meanY+currentString.maxR > maxY) || isnan(maxY)) {
                maxY = currentString.meanY+currentString.maxR;
            }
        }
        
        // calculte cell widths
        cellStartX=minX;
        cellStartY=minY;
        cellWidthX=(maxX-minX)/static_cast<double>(cellNumX);
        cellWidthY=(maxY-minY)/static_cast<double>(cellNumY);
        
        std::set<unsigned short> assignedStringNums;
        
        //unsigned int numAssignedStrings=0;
        
        for (unsigned int i=0;i<cellNumX;++i)
        {
            for (unsigned int j=0;j<cellNumY;++j)
            {
                const double cellXMin = cellStartX+static_cast<double>(i)*cellWidthX;
                const double cellXMax = cellStartX+static_cast<double>(i+1)*cellWidthX;
                const double cellYMin = cellStartY+static_cast<double>(j)*cellWidthY;
                const double cellYMax = cellStartY+static_cast<double>(j+1)*cellWidthY;
                
                bool stringFound=false;
                unsigned long stringFoundNum=0xFFFF;
                // we got a cell, now loop over all strings to find if any one is in here
                
                for (unsigned long thisString=0;thisString<strings.size();++thisString)
                {
                    const stringStruct &currentString = strings[thisString];
                    
                    bool cellContainsStringX=false;
                    bool cellContainsStringY=false;
                    
                    if ((currentString.meanX-currentString.maxR <= cellXMin) &&
                        (currentString.meanX+currentString.maxR >= cellXMin))
                        cellContainsStringX=true;
                    if ((currentString.meanX-currentString.maxR <= cellXMax) &&
                        (currentString.meanX+currentString.maxR >= cellXMax))
                        cellContainsStringX=true;
                    if ((currentString.meanX-currentString.maxR >= cellXMin) &&
                        (currentString.meanX+currentString.maxR <= cellXMax))
                        cellContainsStringX=true;
                    if ((currentString.meanY-currentString.maxR <= cellYMin) &&
                        (currentString.meanY+currentString.maxR >= cellYMin))
                        cellContainsStringY=true;
                    if ((currentString.meanY-currentString.maxR <= cellYMax) &&
                        (currentString.meanY+currentString.maxR >= cellYMax))
                        cellContainsStringY=true;
                    if ((currentString.meanY-currentString.maxR >= cellYMin) &&
                        (currentString.meanY+currentString.maxR <= cellYMax))
                        cellContainsStringY=true;
                    
                    if ((cellContainsStringX) && (cellContainsStringY))
                    {
                        if (stringFound) return false; // two strings per cell -> fail!
                        stringFound=true;
                        stringFoundNum=thisString;
                        assignedStringNums.insert(thisString);
                        //++numAssignedStrings;
                    }
                } //for(string)
                
                if (stringFound) {
                    cellToStringIndex[j*cellNumX+i] = stringFoundNum;
                } else {
                    cellToStringIndex[j*cellNumX+i] = 0xFFFF;
                }
                
                
            } // for(j)
        } // for(i)
        
        
        if (assignedStringNums.size()!=strings.size()) {
            std::cerr << "Internal error in cell division algorithm." << std::endl;
        }
        
        return true;
        
    }
    
    bool doesMatchLayering(const stringStruct &currentString,
                           double layerStartZ,
                           double layerHeight,
                           unsigned int layerNum,
                           const double domRadius,
                           const std::vector<unsigned char> &layerToOMNumIndex)
    {
        if (layerNum==0) return false;
        if (domRadius < 0.) return false;
        if (currentString.doms.size() >= 0xFF) {
            std::cerr << "Dom numbers >= 255 are not supported!" << std::endl;
            exit(-4);
        }
        if (layerToOMNumIndex.size() != layerNum)
        {
            std::cerr << "Internal error: layerToOMNumIndex.size() != layerNum" << std::endl;
            exit(-4);
        }
        
        for (unsigned int i=0;i<layerNum;++i)
        {
            const double layerZMin = layerStartZ+static_cast<double>(i)*layerHeight;
            const double layerZMax = layerStartZ+static_cast<double>(i+1)*layerHeight;
            
            unsigned char layerShouldContainDom=0xFF;
            
            for (unsigned long thisDom=0;thisDom<currentString.doms.size();++thisDom)
            {
                const domStruct &currentDom = currentString.doms[thisDom];
                double domZ = currentDom.posZ;
                
                bool layerContainsDom=false;
                
                if ((domZ-domRadius <= layerZMin) &&
                    (domZ+domRadius >= layerZMin))
                    layerContainsDom=true;
                if ((domZ-domRadius <= layerZMax) &&
                    (domZ+domRadius >= layerZMax))
                    layerContainsDom=true;
                if ((domZ-domRadius >= layerZMin) &&
                    (domZ+domRadius <= layerZMax))
                    layerContainsDom=true;
                
                
                if (layerContainsDom)
                {
                    if (layerShouldContainDom!=0xFF) {
                        return false; // two different doms from the same string per layer -> fail!
                    } else {
                        layerShouldContainDom = thisDom;
                    }
                }
                
            } // for(dom)
            
            if (layerToOMNumIndex[i] != layerShouldContainDom) {
                //std::cout << "Layer " << i << " should contain OM " << (int)layerToOMNumIndex[i] << " but contains " << (int)layerShouldContainDom << std::endl;
                return false; // incompatible
            }
            
        } // for (i)
        
        return true; // everything is compatible
    }
    
    void findOverallStringMinMaxZ(const std::vector<stringStruct> &strings,
                                  const double domRadius,
                                  double &minZ,
                                  double &maxZ)
    {
        minZ=maxZ=NAN;
        
        BOOST_FOREACH(const stringStruct& currentString, strings)
        {
            if ((currentString.minZ-domRadius < minZ) || isnan(minZ)) {
                minZ = currentString.minZ-domRadius;
            }
            if ((currentString.maxZ+domRadius > maxZ) || isnan(maxZ)) {
                maxZ = currentString.maxZ+domRadius;
            }
        }	
    }
    
    bool divideIntoLayers(const stringStruct &currentString,
                          double &layerStartZ,
                          double &layerHeight,
                          unsigned int layerNum,
                          const double domRadius,
                          double minZHint, double maxZHint,
                          std::vector<unsigned char> &layerToOMNumIndex)
    {
        if (layerNum==0) return false;
        if (domRadius < 0.) return false;
        if (currentString.doms.size() >= 0xFF) {
            std::cerr << "Dom numbers >= 255 are not supported!" << std::endl;
            exit(-4);
        }
        
        // set all layers on each string to "no doms inside"
        layerToOMNumIndex.assign(layerNum, 0xFF);
        
        // find minimum and maximum z detector coordinates
        double minZ=minZHint, maxZ=maxZHint;
        if ((currentString.minZ-domRadius < minZ) || isnan(minZ)) {
            minZ = currentString.minZ-domRadius;
        }
        if ((currentString.maxZ+domRadius > maxZ) || isnan(maxZ)) {
            maxZ = currentString.maxZ+domRadius;
        }
        
        // calculate layer heights
        layerStartZ=minZ;
        layerHeight=(maxZ-minZ)/static_cast<double>(layerNum);
        
        for (unsigned int i=0;i<layerNum;++i)
        {
            const double layerZMin = layerStartZ+static_cast<double>(i)*layerHeight;
            const double layerZMax = layerStartZ+static_cast<double>(i+1)*layerHeight;
            
            // we got a layer, now loop over all strings to find if any one is in here
            
            for (unsigned long thisDom=0;thisDom<currentString.doms.size();++thisDom)
            {
                const domStruct &currentDom = currentString.doms[thisDom];
                double domZ = currentDom.posZ;
                
                bool layerContainsDom=false;
                
                if ((domZ-domRadius <= layerZMin) &&
                    (domZ+domRadius >= layerZMin))
                    layerContainsDom=true;
                if ((domZ-domRadius <= layerZMax) &&
                    (domZ+domRadius >= layerZMax))
                    layerContainsDom=true;
                if ((domZ-domRadius >= layerZMin) &&
                    (domZ+domRadius <= layerZMax))
                    layerContainsDom=true;
                
                
                if (layerContainsDom)
                {
                    if (layerToOMNumIndex[i]!=0xFF) {
                        return false; // two different doms from the same string per layer -> fail!
                    } else {
                        layerToOMNumIndex[i] = thisDom;
                    }
                }
                
            } // for(dom)
            
        } // for(i)
        
        return true;	
    }
    
    
    bool write_geometry_code_and_fill_buffer(std::string &code, 
                                             const std::vector<int> &stringIDs,
                                             const std::vector<unsigned int> &domIDs,
                                             const std::vector<double> &posX,
                                             const std::vector<double> &posY,
                                             const std::vector<double> &posZ,
                                             const double omRadius,
                                             std::vector<cl_int> &domIDbuffer,
                                             std::vector<cl_float> &domPosBuffer,
                                             std::vector<cl_uchar> &geoLayerToOMNumIndexPerStringSetBuffer
                                             )
    {
        typedef std::vector<int>::size_type sizeType;
        
        sizeType numEntries=stringIDs.size();
        if (numEntries==0) return false;
        if ((domIDs.size() != numEntries) ||
            (posX.size() != numEntries) ||
            (posY.size() != numEntries) ||
            (posZ.size() != numEntries))
            return false;
        if (omRadius < 0.) return false;
        
        std::set<int> stringIDSet;
        BOOST_FOREACH(int stringID, stringIDs) {stringIDSet.insert(stringID);}
        unsigned long numberOfStrings = stringIDSet.size();
        
        #define MAX_SUPPORTED_NUM_STRINGS 0xFFFF-1
        if (numberOfStrings >= MAX_SUPPORTED_NUM_STRINGS) {
            std::cerr << "More than " << MAX_SUPPORTED_NUM_STRINGS << " are not supported." << std::endl;
            return false;
        }
        
        std::vector<stringStruct> strings(numberOfStrings);
        unsigned int stringIndex=0;
        unsigned long maxNumDoms=0;
        double stringMaxR=NAN;
        BOOST_FOREACH(int stringID, stringIDSet)
        {
            stringStruct &currentStringStruct = strings[stringIndex];
            
            currentStringStruct.stringID = stringID;
            currentStringStruct.maxZ=NAN;
            currentStringStruct.minZ=NAN;
            currentStringStruct.meanX=0.;
            currentStringStruct.meanY=0.;
            currentStringStruct.maxR=NAN;
            currentStringStruct.doms.clear();
            
            // loop over all doms. only use them if they are on the current string
            unsigned long numDoms=0;
            for (unsigned long i=0;i<numEntries;++i)
            {
                if (stringIDs[i]!=stringID) continue;
                // index i is on the current string!
                
                currentStringStruct.meanX += posX[i];
                currentStringStruct.meanY += posY[i];
                if ((posZ[i] > currentStringStruct.maxZ) || isnan(currentStringStruct.maxZ))
                    currentStringStruct.maxZ = posZ[i];
                if ((posZ[i] < currentStringStruct.minZ) || isnan(currentStringStruct.minZ))
                    currentStringStruct.minZ = posZ[i];
                
                // insert this dom
                currentStringStruct.doms.push_back(domStruct());
                domStruct &currentDomStruct = currentStringStruct.doms.back();
                
                currentDomStruct.domID = domIDs[i];
                currentDomStruct.posX = posX[i];
                currentDomStruct.posY = posY[i];
                currentDomStruct.posZ = posZ[i];
                
                ++numDoms;
            }
            currentStringStruct.meanX /= static_cast<double>(numDoms);
            currentStringStruct.meanY /= static_cast<double>(numDoms);
            
            if (numDoms > maxNumDoms) maxNumDoms=numDoms;
            
            // calculate the string radius (will be the OM radius for a straight string)
            for (unsigned long i=0;i<numEntries;++i)
            {
                if (stringIDs[i]!=stringID) continue;
                // index i is on the current string!
                
                const double dX = currentStringStruct.meanX - posX[i];
                const double dY = currentStringStruct.meanY - posY[i];
                const double thisR = std::sqrt(dX*dX + dY*dY)+omRadius;
                
                if ((thisR > currentStringStruct.maxR) || isnan(currentStringStruct.maxR))
                    currentStringStruct.maxR = thisR;
                
                if ((thisR > stringMaxR) || isnan(stringMaxR))
                    stringMaxR = thisR;
            }
            
            ++stringIndex;
        }
        
        
        // Try to split the detector into xy "cells" with 0 or 1 strings per cell.
        // We do not need to optimize this, so we do a brute froce approach:
        // start with only one cell and subdivide it until the requirement 
        // max(Nstringpercell)==1 is fulfilled.
        unsigned int cellGridNumX=1;
        unsigned int cellGridNumY=1;
        std::vector<unsigned short> cellToStringIndex;
        double cellStartX, cellStartY, cellWidthX, cellWidthY;
        for(;;)
        {
            bool divisionIsPossible = divideIntoCells(strings,
                                                      cellStartX,
                                                      cellStartY,
                                                      cellWidthX,
                                                      cellWidthY,
                                                      cellGridNumX,
                                                      cellGridNumY,
                                                      cellToStringIndex);
            
            if (divisionIsPossible) break;
            ++cellGridNumX;
            ++cellGridNumY;
            
            if (cellGridNumX >= 1000) {
                std::cerr << "There does not seem to be a possible cell division for your detector." << std::endl;
                exit(-3);
            }
        }
        log_debug("Geometry cell division: %ux%u", cellGridNumX, cellGridNumY);
        log_debug("from x=%fm, width=%fm", cellStartX, cellWidthX);
        log_debug("from y=%fm, width=%fm", cellStartY, cellWidthY);
        
        // try to split the detector into z "layers" with either a single dom number in it or
        // no dom number at all. We restrict ourselves to a detector where dom z-positions are
        // correlated to their numbers.
        
        unsigned int numStringSets=0;
        std::vector<unsigned int> geoLayerNum;
        std::vector<double> layerStartZ, layerHeight;
        
        std::vector<std::vector<unsigned char> > layerToOMNumIndexPerStringSet;
        std::vector<unsigned char> stringInStringSet(strings.size()); 
        
        double minZHint, maxZHint;
        findOverallStringMinMaxZ(strings, omRadius, minZHint, maxZHint);
        
        unsigned int maxLayerNum=0;
        for (unsigned int stringNum=0;stringNum<strings.size();++stringNum)
        {
            //std::cout << "checking string " << stringNum << std::endl;
            // first check if the current string matches one of the previous layer division
            
            bool matchFound=false; unsigned int existingStringSetNum;
            for (unsigned int stringSetNum=0;stringSetNum<numStringSets;++stringSetNum)
            {
                //std::cout << "  cheking if it matches layering " << stringSetNum << std::endl;
                
                bool ret = doesMatchLayering(strings[stringNum],
                                             layerStartZ[stringSetNum],
                                             layerHeight[stringSetNum],
                                             geoLayerNum[stringSetNum],
                                             omRadius,
                                             layerToOMNumIndexPerStringSet[stringSetNum]);
                if (ret) {existingStringSetNum=stringSetNum;matchFound=true; break;}
            }
            if (matchFound)
            {
                //std::cout << "  YES!" << std::endl;
                
                // not much work to be done here
                stringInStringSet[stringNum] = existingStringSetNum;
            }
            else
            {
                stringInStringSet[stringNum] = numStringSets;
                //std::cout << "  NO -> creating new layering " << numStringSets << std::endl;
                
                // need to create a new layering for this string
                ++numStringSets;
                if (numStringSets >= 0xFF) {
                    std::cerr << "Not more than 255 different string layer divisions (\"string sets\") are supported!" << std::endl;
                    exit(-5);
                }
                
                layerStartZ.push_back(NAN);
                layerHeight.push_back(NAN);
                geoLayerNum.push_back(1);
                layerToOMNumIndexPerStringSet.push_back(std::vector<unsigned char>());
                
                for(;;)
                {
                    bool divisionIsPossible = divideIntoLayers(strings[stringNum],
                                                               layerStartZ.back(),
                                                               layerHeight.back(),
                                                               geoLayerNum.back(),
                                                               omRadius,
                                                               minZHint, maxZHint,
                                                               layerToOMNumIndexPerStringSet.back());
                    if (divisionIsPossible) break;
                    ++geoLayerNum.back();
                    
                    if (geoLayerNum.back() >= 1000) {
                        std::cerr << "There does not seem to be a possible layer division for your detector." << std::endl;
                        exit(-3);
                    }
                }
                
                if (geoLayerNum.back()>maxLayerNum) maxLayerNum=geoLayerNum.back();
                
                //std::cout << "   new layering created! Contains " << geoLayerNum.back() << " layers." << std::endl;
                //for (unsigned int l=0;l<geoLayerNum.back();++l)
                //{
				//if (layerToOMNumIndexPerStringSet.back()[l] == 0xFF) continue;
				//std::cout << "    layer " << l << " -> OM " << (int)(layerToOMNumIndexPerStringSet.back()[l]) << std::endl;
				
                //}
                
            } // end if (matchfound)
            
        } // for (stringNum)
        
        std::vector<unsigned char> geoLayerToOMNumIndex(maxLayerNum*numStringSets, 0xFF);
        for (unsigned int j=0;j<numStringSets;++j)
        {
            for (unsigned int i=0;i<geoLayerNum[j];++i)
            {
                geoLayerToOMNumIndex[j*maxLayerNum+i] = layerToOMNumIndexPerStringSet[j][i];
            }
        }
        
        log_info("There are %u string sets:", numStringSets);
        for (unsigned int stringSetNum=0;stringSetNum<numStringSets;++stringSetNum)
        {
            log_info(" * Set %u:", stringSetNum);
            log_info("   Geometry layer division: %u layers", geoLayerNum[stringSetNum]);
            log_info("   from z=%fm, height=%fm",
                     layerStartZ[stringSetNum],
                     layerHeight[stringSetNum]);
        }
        
        
        double geoDomPosMaxAbsX=NAN;
        double geoDomPosMaxAbsY=NAN;
        double geoDomPosMaxAbsZ=NAN;
        for (sizeType i=0;i<numberOfStrings;++i)
        {
            for (unsigned long j=0;j<strings[i].doms.size();++j)
            {
                domStruct &currentDomStruct = strings[i].doms[j];
                
                double absX = fabs(currentDomStruct.posX);
                double absY = fabs(currentDomStruct.posY);
                double absZ = fabs(currentDomStruct.posZ);
                
                if ((absX > geoDomPosMaxAbsX) || isnan(geoDomPosMaxAbsX)) geoDomPosMaxAbsX=absX;
                if ((absY > geoDomPosMaxAbsY) || isnan(geoDomPosMaxAbsY)) geoDomPosMaxAbsY=absY;
                if ((absZ > geoDomPosMaxAbsZ) || isnan(geoDomPosMaxAbsZ)) geoDomPosMaxAbsZ=absZ;
            }
        }
        
        
        
        // dom information goes to a memory buffer (i.e. global memory)
        
        domIDbuffer.assign(numberOfStrings*maxNumDoms, 0);
        domPosBuffer.assign(numberOfStrings*maxNumDoms*4, NAN);
        
        for (sizeType i=0;i<numberOfStrings;++i)
        {
            for (unsigned long j=0;j<strings[i].doms.size();++j)
            {
                domStruct &currentDomStruct = strings[i].doms[j];
                
                domIDbuffer[i*maxNumDoms + j]  = currentDomStruct.domID;
                domPosBuffer[i*(maxNumDoms*4)+j*4 + 0] = currentDomStruct.posX;
                domPosBuffer[i*(maxNumDoms*4)+j*4 + 1] = currentDomStruct.posY;
                domPosBuffer[i*(maxNumDoms*4)+j*4 + 2] = currentDomStruct.posZ;
                domPosBuffer[i*(maxNumDoms*4)+j*4 + 3] = NAN;
                
                //std::cout << "string=" << i << " dom=" << j << ": pos=(" << currentDomStruct.posX << "," << currentDomStruct.posY << "," << currentDomStruct.posZ << ")" << std::endl;
                
            }
        }
        
        unsigned int geoLayerToOMNumIndexPerStringSetBuffer_size = ((numStringSets*maxLayerNum)/64)+1;
        geoLayerToOMNumIndexPerStringSetBuffer_size *= 64;
        log_info("BSize: %u -> %u", numStringSets*maxLayerNum, geoLayerToOMNumIndexPerStringSetBuffer_size);
        
        geoLayerToOMNumIndexPerStringSetBuffer.assign(geoLayerToOMNumIndexPerStringSetBuffer_size,0xFF);
        for (unsigned int i=0;i<numStringSets*maxLayerNum;++i)
        {
            geoLayerToOMNumIndexPerStringSetBuffer[i] = geoLayerToOMNumIndex[i];
        }
        
        
        // string information goes to the constant memory
        
        // prepare the output buffer
        std::ostringstream output(std::ostringstream::out);
        
        // write the output buffer
        output << "// this is auto-generated code created by write_geometry_code_and_fill_buffer()" << std::endl;
        output << std::endl;
        
        
        output.setf(std::ios::scientific,std::ios::floatfield);
        output.precision(std::numeric_limits<float>::digits10+4); // maximum precision for a float
        
        
        output << "#define NUM_STRINGS " << numberOfStrings << std::endl;
        output << "#define MAX_NUM_DOMS_PER_STRINGS " << maxNumDoms << std::endl;
        output << "#define OM_RADIUS " << omRadius << "f" << std::endl;
        
        output << "#define GEO_CELL_NUM_X " << cellGridNumX << std::endl;
        output << "#define GEO_CELL_NUM_Y " << cellGridNumY << std::endl;
        output << "#define GEO_CELL_WIDTH_X " << cellWidthX << "f" << std::endl;
        output << "#define GEO_CELL_WIDTH_Y " << cellWidthY << "f" << std::endl;
        output << "#define GEO_CELL_START_X " << cellStartX << "f" << std::endl;
        output << "#define GEO_CELL_START_Y " << cellStartY << "f" << std::endl;
        
        output << "#define GEO_LAYER_STRINGSET_NUM " << numStringSets << std::endl;
        output << "#define GEO_LAYER_STRINGSET_MAX_NUM_LAYERS " << maxLayerNum << std::endl;
        
        output << std::endl;
        
        //output << "__constant const short geoStringIDs[NUM_STRINGS] = {" << std::endl;
        //for (sizeType j=0;j<numberOfStrings;++j){     
        //	output << "  " << strings[j].stringID << ", " << std::endl;
        //}
        //output << "};" << std::endl;
        //output << std::endl;
        
        output << "__constant unsigned char geoStringNumDoms[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<numberOfStrings;++j){     
            output << "  " << strings[j].doms.size() << ", " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        output << "__constant float geoStringPosX[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<numberOfStrings;++j){     
            output << "  " << strings[j].meanX << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        output << "__constant float geoStringPosY[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<numberOfStrings;++j){     
            output << "  " << strings[j].meanY << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        output << "#define GEO_STRING_MAX_RADIUS " << stringMaxR << "f" << std::endl;
        output << "__constant float geoStringRadius[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<numberOfStrings;++j){     
            output << "  " << strings[j].maxR << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        output << "__constant float geoStringMinZ[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<numberOfStrings;++j){     
            output << "  " << strings[j].minZ << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        output << "__constant float geoStringMaxZ[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<numberOfStrings;++j){     
            output << "  " << strings[j].maxZ << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        
        // we only have a limited amount of constant memory. this needs lots of memory,
        // so store it as shorts with a known multiplier.
        output << "#define GEO_DOM_POS_MAX_ABS_X " << geoDomPosMaxAbsX << "f" << std::endl;
        output << "__constant short geoDomPosX[NUM_STRINGS*MAX_NUM_DOMS_PER_STRINGS] = {" << std::endl;
        for (sizeType i=0;i<numberOfStrings;++i){     
            for (sizeType j=0;j<maxNumDoms;++j){    
                short value = static_cast<short>((domPosBuffer[i*(maxNumDoms*4)+j*4 + 0]/geoDomPosMaxAbsX)*32767.);
                
                output << "  " << value << ", // string=" << i << ", dom=" << j << std::endl;
            }
        }
        output << "};" << std::endl;
        
        output << "#define GEO_DOM_POS_MAX_ABS_Y " << geoDomPosMaxAbsY << "f" << std::endl;
        output << "__constant short geoDomPosY[NUM_STRINGS*MAX_NUM_DOMS_PER_STRINGS] = {" << std::endl;
        for (sizeType i=0;i<numberOfStrings;++i){     
            for (sizeType j=0;j<maxNumDoms;++j){    
                short value = static_cast<short>((domPosBuffer[i*(maxNumDoms*4)+j*4 + 1]/geoDomPosMaxAbsY)*32767.);
                
                output << "  " << value << ", // string=" << i << ", dom=" << j << std::endl;
            }
        }
        output << "};" << std::endl;
        
        output << "#define GEO_DOM_POS_MAX_ABS_Z " << geoDomPosMaxAbsZ << "f" << std::endl;
        output << "__constant short geoDomPosZ[NUM_STRINGS*MAX_NUM_DOMS_PER_STRINGS] = {" << std::endl;
        for (sizeType i=0;i<numberOfStrings;++i){     
            for (sizeType j=0;j<maxNumDoms;++j){    
                short value = static_cast<short>((domPosBuffer[i*(maxNumDoms*4)+j*4 + 2]/geoDomPosMaxAbsZ)*32767.);
                
                output << "  " << value << ", // string=" << i << ", dom=" << j << std::endl;
            }
        }
        output << "};" << std::endl;
        
        output << "__constant unsigned short geoCellIndex[GEO_CELL_NUM_X*GEO_CELL_NUM_Y] = {" << std::endl;
        for (sizeType j=0;j<cellGridNumY;++j){
            for (sizeType i=0;i<cellGridNumX;++i){     
                unsigned short value = cellToStringIndex[j*cellGridNumX+i];
                if (value == 0xFFFF) {
                    output << "  " << "0xFFFF" << ", " << std::endl;
                } else {
                    output << "  " << value << ", " << std::endl;
                }
            }
        }
        output << "};" << std::endl;
        
        
        output << "__constant unsigned char geoStringInStringSet[NUM_STRINGS] = {" << std::endl;
        for (unsigned int i=0;i<numberOfStrings;++i)
        {
            output << "  " << (int)stringInStringSet[i] << ", " << std::endl;
        }
        output << "};" << std::endl;
        
        output << "__constant unsigned short geoLayerNum[GEO_LAYER_STRINGSET_NUM] = {" << std::endl;
        for (unsigned int i=0;i<numStringSets;++i)
        {
            output << "  " << geoLayerNum[i] << ", " << std::endl;
        }
        output << "};" << std::endl;
        
        output << "__constant float geoLayerStartZ[GEO_LAYER_STRINGSET_NUM] = {" << std::endl;
        for (unsigned int i=0;i<numStringSets;++i)
        {
            output << "  " << layerStartZ[i] << "f, " << std::endl;
        }
        output << "};" << std::endl;
        
        output << "__constant float geoLayerHeight[GEO_LAYER_STRINGSET_NUM] = {" << std::endl;
        for (unsigned int i=0;i<numStringSets;++i)
        {
            output << "  " << layerHeight[i] << "f, " << std::endl;
        }
        output << "};" << std::endl;
        
        output << "#define GEO_geoLayerToOMNumIndexPerStringSet_BUFFER_SIZE " << geoLayerToOMNumIndexPerStringSetBuffer_size << std::endl;
        output << "__constant unsigned char geoLayerToOMNumIndexPerStringSet[GEO_LAYER_STRINGSET_NUM*GEO_LAYER_STRINGSET_MAX_NUM_LAYERS] = {" << std::endl;
        for (unsigned int j=0;j<numStringSets;++j)
        {
            for (unsigned int i=0;i<maxLayerNum;++i)
            {
                unsigned int value = geoLayerToOMNumIndex[j*maxLayerNum+i];
                if (value == 0xFF) {
                    output << "  " << "0xFF" << ", ";
                } else {
                    output << "  " << value << ", ";
                }
            }
            output << std::endl;
        }
        output << "};" << std::endl;
        
        // return the code we just wrote to the caller
        code = output.str();
        
        return true;
    }
    
    

};
