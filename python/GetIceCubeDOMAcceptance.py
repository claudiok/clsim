from icecube import icetray, dataclasses
from icecube.clsim import I3CLSimFunctionFromTable

from I3Tray import I3Units

import numpy, math
from os.path import expandvars


def GetIceCubeDOMAcceptance(domRadius = 0.16510*I3Units.m, efficiency=1.0):
    # this is taken from photonics/lib/efficiency.h:
    #
    #################################################################
    # Adopted into photonics Juli 1 2007 /Johan. Interpolation of data
    # from Kotoyo Hoshina <kotoyo.hoshina@icecube.wisc.edu>: 
    # Jan 15 K.Hoshina :
    # Found a wrong value at 260nm whicn I didn't offer in July 1st 2007.
    # Copied a value from 270nm.
    #          0.0002027029 -> 0.0000064522
    #################################################################
    # ROMEO wavelength effective area
    #
    # This is the table of photo-electron acceptance of the
    # IceCube PMT after through the glass+gel + PMT photocathode,
    # as a function of wavelength.
    # It corresponds to a 0p.e. threshold.
    # The injection angle (off-axis angle) is 0deg.
    #
    # The acceptances are calculated by:
    #
    # acceptance = NPEs generated by photo-cathode (0P.E threshold)
    #              / Nphotons_inject_to_1m^2
    #################################################################
    dom2007a_eff_area = [
    0.0000064522,
    0.0000064522,
    0.0000064522,
    0.0000064522,
    0.0000021980,
    0.0001339040,
    0.0005556810,
    0.0016953000,
    0.0035997000,
    0.0061340900,
    0.0074592700,
    0.0090579800,
    0.0099246700,
    0.0105769000,
    0.0110961000,
    0.0114214000,
    0.0114425000,
    0.0111527000,
    0.0108086000,
    0.0104458000,
    0.0099763100,
    0.0093102500,
    0.0087516600,
    0.0083225800,
    0.0079767200,
    0.0075625100,
    0.0066377000,
    0.0053335800,
    0.0043789400,
    0.0037583500,
    0.0033279800,
    0.0029212500,
    0.0025334900,
    0.0021115400,
    0.0017363300,
    0.0013552700,
    0.0010546600,
    0.0007201020,
    0.0004843820,
    0.0002911110,
    0.0001782310,
    0.0001144300,
    0.0000509155]
    dom2007a_eff_area = numpy.array(dom2007a_eff_area)*I3Units.meter2 # apply units (this is an effective area)
    domArea = math.pi*domRadius**2.
    dom2007a_efficiency = efficiency*(dom2007a_eff_area/domArea)

    domEfficiency = I3CLSimFunctionFromTable(260.*I3Units.nanometer, 10.*I3Units.nanometer, dom2007a_efficiency)

    return domEfficiency
